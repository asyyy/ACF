// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion{
  implicit def int2int(i:utilities.Datatype.Int.int):Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i)=>Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
    else {
      val (r, s): (BigInt, BigInt) =
        ((k: BigInt) => (l: BigInt) => if (l == 0) (BigInt(0), k) else
          (k.abs /% l.abs)).apply(k).apply(BigInt(2));
      ((if (BigInt(0) < k) r else (- r) - s), s == BigInt(1))
    })

  def char_of_integer(k: BigInt): String.char =
  {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    String.Chara(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil) => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[String.char] ={
    (l.map(c => { val k: Int = c.toInt; if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal") })).map(a => char_of_integer(a))
  }

  def explode(s: String): List[String.char] ={
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s:String):List[String.char]= explode(s)

  // conversion from Scala List[Char] to HOL List[String.char]
  implicit def charList2charList(l:List[Char]):List[String.char]= explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[String.char] on first position
  implicit def tupleString2tupleString[T](t:(List[Char],T)):
  (List[String.char],T)= t match { case (e1,e2) => (charList2charList(e1),e2)}

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2Dataint(i:Int.int):utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i)=>utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: String.char): Char = {
    x match {
      case String.Chara(x1,x2,x3,x4,x5,x6,x7,x8) => {
        var n = 0;
        n = if (x8) 2*n+1 else 2*n;
        n = if (x7) 2*n+1 else 2*n;
        n = if (x6) 2*n+1 else 2*n;
        n = if (x5) 2*n+1 else 2*n;
        n = if (x4) 2*n+1 else 2*n;
        n = if (x3) 2*n+1 else 2*n;
        n = if (x2) 2*n+1 else 2*n;
        n = if (x1) 2*n+1 else 2*n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[String.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._


object HOL {

  trait equal[A] {
    val `HOL.equal`: (A, A) => Boolean
  }
  def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
  object equal {
    implicit def `String.equal_char`: equal[String.char] = new equal[String.char]
    {
      val `HOL.equal` = (a: String.char, b: String.char) =>
        String.equal_chara(a, b)
    }
    implicit def `Lista.equal_list`[A : equal]: equal[List[A]] = new
        equal[List[A]] {
      val `HOL.equal` = (a: List[A], b: List[A]) => Lista.equal_lista[A](a, b)
    }
    implicit def `tp67.equal_abs`: equal[tp67.abs] = new equal[tp67.abs] {
      val `HOL.equal` = (a: tp67.abs, b: tp67.abs) => tp67.equal_absa(a, b)
    }
  }

  def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Num {

  abstract sealed class num
  final case class One() extends num
  final case class Bit0(a: num) extends num
  final case class Bit1(a: num) extends num

} /* object Num */

object Code_Numeral {

  def integer_of_int(x0: Int.int): BigInt = x0 match {
    case Int.int_of_integer(k) => k
  }

} /* object Code_Numeral */

object Int {

  abstract sealed class int
  final case class int_of_integer(a: BigInt) extends int

  def one_int: int = int_of_integer(BigInt(1))

  def plus_int(k: int, l: int): int =
    int_of_integer(Code_Numeral.integer_of_int(k) +
      Code_Numeral.integer_of_int(l))

  def zero_int: int = int_of_integer(BigInt(0))

  def equal_int(k: int, l: int): Boolean =
    Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

  def minus_int(k: int, l: int): int =
    int_of_integer(Code_Numeral.integer_of_int(k) -
      Code_Numeral.integer_of_int(l))

} /* object Int */

object Product_Type {

  def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
    case (p, true) => p
    case (p, false) => ! p
    case (true, p) => p
    case (false, p) => ! p
  }

} /* object Product_Type */

object String {

  abstract sealed class char
  final case class
  Chara(a: Boolean, b: Boolean, c: Boolean, d: Boolean, e: Boolean, f: Boolean,
        g: Boolean, h: Boolean)
    extends char

  def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
    case (Chara(x1, x2, x3, x4, x5, x6, x7, x8),
    Chara(y1, y2, y3, y4, y5, y6, y7, y8))
    => Product_Type.equal_bool(x1, y1) &&
      (Product_Type.equal_bool(x2, y2) &&
        (Product_Type.equal_bool(x3, y3) &&
          (Product_Type.equal_bool(x4, y4) &&
            (Product_Type.equal_bool(x5, y5) &&
              (Product_Type.equal_bool(x6, y6) &&
                (Product_Type.equal_bool(x7, y7) &&
                  Product_Type.equal_bool(x8, y8)))))))
  }

} /* object String */

object Lista {

  def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
    case (Nil, x21 :: x22) => false
    case (x21 :: x22, Nil) => false
    case (x21 :: x22, y21 :: y22) =>
      HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
    case (Nil, Nil) => true
  }

  def hd[A](x0: List[A]): A = x0 match {
    case x21 :: x22 => x21
  }

} /* object Lista */

object tp67 {

  abstract sealed class abs
  final case class Undefined() extends abs
  final case class Defined(a: Int.int) extends abs

  def equal_absa(x0: abs, x1: abs): Boolean = (x0, x1) match {
    case (Undefined(), Defined(x2)) => false
    case (Defined(x2), Undefined()) => false
    case (Defined(x2), Defined(y2)) => Int.equal_int(x2, y2)
    case (Undefined(), Undefined()) => true
  }

  abstract sealed class option[A]
  final case class None[A]() extends option[A]
  final case class Some[A](a: A) extends option[A]

  abstract sealed class boolabs
  final case class Trueabs() extends boolabs
  final case class Falseabs() extends boolabs
  final case class Anyabs() extends boolabs

  def verifsan(x0: List[(List[(List[String.char], abs)], Boolean)]): Boolean = x0
  match {
    case Nil => true
    case (t, ouch) :: xs => (if (ouch) verifsan(xs) else false)
  }

  def equal_boolabs(x0: boolabs, x1: boolabs): Boolean = (x0, x1) match {
    case (Falseabs(), Anyabs()) => false
    case (Anyabs(), Falseabs()) => false
    case (Trueabs(), Anyabs()) => false
    case (Anyabs(), Trueabs()) => false
    case (Trueabs(), Falseabs()) => false
    case (Falseabs(), Trueabs()) => false
    case (Anyabs(), Anyabs()) => true
    case (Falseabs(), Falseabs()) => true
    case (Trueabs(), Trueabs()) => true
  }

  def equal_option[A : HOL.equal](x0: option[A], x1: option[A]): Boolean =
    (x0, x1) match {
      case (None(), Some(x2)) => false
      case (Some(x2), None()) => false
      case (Some(x2), Some(y2)) => HOL.eq[A](x2, y2)
      case (None(), None()) => true
    }

  def assoc[A : HOL.equal, B](uu: A, x1: List[(A, B)]): option[B] = (uu, x1) match
  {
    case (uu, Nil) => None[B]()
    case (x1, (x, y) :: xs) =>
      (if (HOL.eq[A](x, x1)) Some[B](y) else assoc[A, B](x1, xs))
  }

  def combine(x0: List[(List[String.char], abs)],
              t: List[(List[String.char], abs)]):
  List[(List[String.char], abs)]
  =
    (x0, t) match {
      case (Nil, t) => t
      case ((x, y) :: z, t) =>
      {
        val res: option[abs] = assoc[List[String.char], abs](x, t);
        (if (equal_option[abs](res, Some[abs](y))) (x, y) :: combine(z, t)
        else (x, Undefined()) :: combine(z, t))
      }
    }

  def plusabs(x0: abs, uu: abs): abs = (x0, uu) match {
    case (Undefined(), uu) => Undefined()
    case (Defined(v), Undefined()) => Undefined()
    case (Defined(x), Defined(y)) =>
      (if (Int.equal_int(Int.plus_int(x, y), Int.zero_int)) Undefined()
      else Defined(Int.plus_int(x, y)))
  }

  def moinabs(x0: abs, uu: abs): abs = (x0, uu) match {
    case (Undefined(), uu) => Undefined()
    case (Defined(v), Undefined()) => Undefined()
    case (Defined(x), Defined(y)) =>
      (if (Int.equal_int(Int.minus_int(x, y), Int.zero_int)) Undefined()
      else Defined(Int.minus_int(x, y)))
  }

  def evale2(x0: expression, e: List[(List[String.char], abs)]): abs = (x0, e)
  match {
    case (Constant(c), e) =>
      (if (Int.equal_int(c, Int.zero_int)) Undefined() else Defined(c))
    case (Variable(s), e) => (assoc[List[String.char], abs](s, e) match {
      case None() => Undefined()
      case Some(y) => y
    })
    case (Sum(e1, e2), e) => plusabs(evale2(e1, e), evale2(e2, e))
    case (Sub(e1, e2), e) => moinabs(evale2(e1, e), evale2(e2, e))
  }

  def eqabs(x0: abs, uu: abs): boolabs = (x0, uu) match {
    case (Undefined(), uu) => Anyabs()
    case (Defined(v), Undefined()) => Anyabs()
    case (Defined(x), Defined(y)) =>
      (if (Int.equal_int(x, y)) Trueabs() else Falseabs())
  }

  def evalc2(x0: condition, t: List[(List[String.char], abs)]): boolabs = (x0, t)
  match {
    case (Eq(e1, e2), t) => eqabs(evale2(e1, t), evale2(e2, t))
  }

  def evals2(xa0: statement, x: List[(List[(List[String.char], abs)], Boolean)]):
  List[(List[(List[String.char], abs)], Boolean)]
  =
    (xa0, x) match {
      case (Skip, x) => x
      case (Aff(s, e), Nil) =>
      {
        val res: abs = evale2(e, Nil);
        (if (equal_absa(res, Undefined())) List((List((s, Undefined())), false))
        else List((List((s, res)), true)))
      }
      case (Aff(s, e), (t, ouch) :: rest) => ((s:List[String.char], evale2(e, t)) :: t, ouch) :: rest
      case (If(c, s1, s2), Nil) =>
      {
        val res: boolabs = evalc2(c, Nil);
        (if (equal_boolabs(res, Trueabs())) evals2(s1, Nil)
        else (if (equal_boolabs(res, Falseabs())) evals2(s2, Nil)
        else {
          val rest1: List[(List[(List[String.char], abs)], Boolean)]
          = evals2(s1, Nil)
          val rest2: List[(List[(List[String.char], abs)], Boolean)]
          = evals2(s2, Nil)
          val (t1, ouch1): (List[(List[String.char], abs)], Boolean)
          = Lista.hd[(List[(List[String.char], abs)],
            Boolean)](rest1)
          val (t2, ouch2): (List[(List[String.char], abs)], Boolean)
          = Lista.hd[(List[(List[String.char], abs)],
            Boolean)](rest2)
          val ouch3: Boolean = ouch1 && ouch2
          val rest3: List[(List[(List[String.char], abs)], Boolean)]
          = rest1 ++ rest2
          val t3: List[(List[String.char], abs)] = combine(t1, t2);
          (t3, ouch3) :: rest3
        }))
      }
      case (If(c, s1, s2), (t, ouch) :: rest) =>
      {
        val res: boolabs = evalc2(c, t);
        (if (equal_boolabs(res, Trueabs())) evals2(s1, (t, ouch) :: rest)
        else (if (equal_boolabs(res, Falseabs())) evals2(s2, (t, ouch) :: rest)
        else {
          val rest1: List[(List[(List[String.char], abs)], Boolean)]
          = evals2(s1, (t, ouch) :: rest)
          val rest2: List[(List[(List[String.char], abs)], Boolean)]
          = evals2(s2, (t, ouch) :: rest)
          val (t1, ouch1): (List[(List[String.char], abs)], Boolean)
          = Lista.hd[(List[(List[String.char], abs)],
            Boolean)](rest1)
          val (t2, ouch2): (List[(List[String.char], abs)], Boolean)
          = Lista.hd[(List[(List[String.char], abs)],
            Boolean)](rest2)
          val ouch3: Boolean = ouch1 && ouch2
          val rest3: List[(List[(List[String.char], abs)], Boolean)]
          = rest1 ++ rest2
          val t3: List[(List[String.char], abs)] = combine(t1, t2);
          (t3, ouch3) :: rest3
        }))
      }
      case (Seq(s1, s2), Nil) =>
      {
        val rest1: List[(List[(List[String.char], abs)], Boolean)] =
          evals2(s1, Nil)
        val rest2: List[(List[(List[String.char], abs)], Boolean)] =
          evals2(s2, rest1)
        val (t1, ouch1): (List[(List[String.char], abs)], Boolean) =
          Lista.hd[(List[(List[String.char], abs)], Boolean)](rest1)
        val (t2, ouch2): (List[(List[String.char], abs)], Boolean) =
          Lista.hd[(List[(List[String.char], abs)], Boolean)](rest2)
        val ouch3: Boolean = ouch1 && ouch2
        val rest3: List[(List[(List[String.char], abs)], Boolean)] =
          rest1 ++ rest2
        val t3: List[(List[String.char], abs)] = combine(t1, t2);
        (t3, ouch3) :: rest3
      }
      case (Seq(s1, s2), (t, ouch) :: rest) =>
      {
        val rest1: List[(List[(List[String.char], abs)], Boolean)] =
          evals2(s1, (t, ouch) :: rest)
        val rest2: List[(List[(List[String.char], abs)], Boolean)] =
          evals2(s2, (t, ouch) :: rest1)
        val (t1, ouch1): (List[(List[String.char], abs)], Boolean) =
          Lista.hd[(List[(List[String.char], abs)], Boolean)](rest1)
        val (t2, ouch2): (List[(List[String.char], abs)], Boolean) =
          Lista.hd[(List[(List[String.char], abs)], Boolean)](rest2)
        val ouch3: Boolean = ouch1 && ouch2
        val rest3: List[(List[(List[String.char], abs)], Boolean)] =
          rest1 ++ rest2
        val t3: List[(List[String.char], abs)] = combine(t1, t2);
        (t3, ouch3) :: rest3
      }
      case (Read(s), Nil) => List((List((s, Defined(Int.one_int))), true))
      case (Read(s), (t, ouch) :: rest) => ((s:List[String.char], Undefined()) :: t, ouch) :: rest
      case (Print(e), Nil) => Nil
      case (Print(e), (t, ouch) :: rest) => (t, ouch) :: rest
      case (Exec(e), Nil) =>
      {
        val res: abs = evale2(e, Nil);
        (if (equal_absa(res, Undefined())) List((List((Nil, Undefined())), false))
        else List((List((Nil, res)), true)))
      }
      case (Exec(e), (t, ouch) :: rest) =>
      {
        val res: abs = evale2(e, t);
        (if (equal_absa(res, Undefined()) ||
          equal_absa(res, Defined(Int.zero_int)))
          (t, false) :: rest else (t, ouch) :: rest)
      }
    }

  def san(s: statement): Boolean =
  {
    val a: List[(List[(List[String.char], abs)], Boolean)] =
      evals2(s, List((Nil, true)));
    verifsan(a)
  }

} /* object tp67 */
